<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Weft Playground</title>
<style>
  :root {
    --bg: #f4efe8;
    --bg-elev: #fff9f0;
    --panel: #ffffff;
    --text: #1a1d24;
    --muted: #596275;
    --line: #d6cfbf;
    --accent: #1f78c8;
    --accent-ink: #ffffff;
    --card: #fffdf9;
    --card-border: #ded5c2;
    --shadow: 0 18px 40px rgba(40, 28, 12, 0.12);
    --mono: "Cascadia Code", "Consolas", "SFMono-Regular", Menlo, monospace;
    --sans: "Avenir Next", "Segoe UI", "Helvetica Neue", sans-serif;
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    min-height: 100vh;
    font-family: var(--sans);
    background:
      radial-gradient(1200px 500px at 90% -10%, #fff3cc 0%, transparent 55%),
      radial-gradient(900px 500px at 0% 110%, #d8ebff 0%, transparent 60%),
      var(--bg);
    color: var(--text);
  }

  .app {
    min-height: 100vh;
    display: grid;
    grid-template-rows: auto 1fr;
  }

  .topbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    padding: 12px 16px;
    border-bottom: 1px solid var(--line);
    background: color-mix(in srgb, var(--bg-elev), white 28%);
    backdrop-filter: blur(4px);
    position: sticky;
    top: 0;
    z-index: 3;
  }

  .brand {
    display: flex;
    align-items: baseline;
    gap: 10px;
  }

  .brand strong {
    font-size: 1rem;
    letter-spacing: 0.04em;
    text-transform: uppercase;
  }

  .brand small {
    color: var(--muted);
  }

  .actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: flex-end;
  }

  button {
    border: 1px solid var(--line);
    background: var(--panel);
    color: var(--text);
    padding: 7px 10px;
    border-radius: 10px;
    font: inherit;
    cursor: pointer;
  }

  button.primary {
    border-color: color-mix(in srgb, var(--accent), black 10%);
    background: var(--accent);
    color: var(--accent-ink);
  }

  .main {
    display: grid;
    grid-template-columns: minmax(300px, 1fr) minmax(340px, 1fr);
    gap: 12px;
    padding: 12px;
    min-height: 0;
  }

  .panel {
    min-height: 0;
    border: 1px solid var(--line);
    border-radius: 16px;
    overflow: hidden;
    background: var(--panel);
    box-shadow: var(--shadow);
    display: grid;
    grid-template-rows: auto 1fr;
  }

  .panel-head {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    border-bottom: 1px solid var(--line);
    background: var(--bg-elev);
  }

  .panel-head strong {
    font-size: 0.92rem;
    letter-spacing: 0.03em;
    text-transform: uppercase;
  }

  .panel-head span {
    color: var(--muted);
    font-size: 0.84rem;
  }

  textarea,
  pre {
    width: 100%;
    height: 100%;
    margin: 0;
    border: 0;
    resize: none;
    outline: none;
    padding: 14px;
    font-family: var(--mono);
    font-size: 13px;
    line-height: 1.5;
    background: var(--panel);
    color: var(--text);
  }

  pre {
    overflow: auto;
    white-space: pre;
  }

  .right {
    display: grid;
    grid-template-rows: minmax(260px, 1fr) minmax(180px, 0.7fr);
    gap: 12px;
    min-height: 0;
  }

  iframe {
    width: 100%;
    height: 100%;
    border: 0;
    background: #fff;
  }

  .status {
    color: var(--muted);
    font-size: 0.84rem;
  }

  @media (max-width: 980px) {
    .main {
      grid-template-columns: 1fr;
      grid-template-rows: minmax(300px, 1fr) auto;
    }

    .right {
      grid-template-rows: minmax(300px, 1fr) minmax(200px, 0.7fr);
    }
  }
</style>
</head>
<body>
<div class="app">
  <header class="topbar">
    <div class="brand">
      <strong>Weft Playground</strong>
      <small>v0.1 compiler preview</small>
    </div>
    <div class="actions">
      <button id="btnExample">Load Example</button>
      <button id="btnReset">Reset</button>
      <button id="btnCopyWeft">Copy Weft</button>
      <button id="btnCopyHtml">Copy HTML</button>
      <button id="btnDownload" class="primary">Download HTML</button>
    </div>
  </header>

  <main class="main">
    <section class="panel">
      <div class="panel-head">
        <strong>Weft Source</strong>
        <span>One file. No CSS/JS input.</span>
      </div>
      <textarea id="source" spellcheck="false" aria-label="Weft source"></textarea>
    </section>

    <section class="right">
      <section class="panel">
        <div class="panel-head">
          <strong>Live Preview</strong>
          <span id="previewStatus" class="status">Ready</span>
        </div>
        <iframe id="preview" sandbox="allow-scripts"></iframe>
      </section>

      <section class="panel">
        <div class="panel-head">
          <strong>Compiled HTML</strong>
          <span class="status">Single-file output</span>
        </div>
        <pre id="htmlOut"></pre>
      </section>
    </section>
  </main>
</div>

<script>
(() => {
  "use strict";

  const DEFAULT_WEFT = `@title Weft Playground Example
@desc A complete page from one .weft file
@theme default
@accent blue

# Weft <center> <glow>

One file. Looks good. Works everywhere. <muted>

---

:::
## Simple <blue>
No HTML.
No CSS.
No JS files.
:::

:::
## Tags <purple>
This <glow>word</glow> glows.
This <#ff66cc>word</#ff66cc> is custom color.
:::

:::
## Motion <green>
This line fades in <fade>
This line spins <spin>
:::

---

![Pattern](https://images.unsplash.com/photo-1505904267569-c9e4f8f1f4f2?auto=format&fit=crop&w=1200&q=60) <round>

[Get Started](https://example.com) <button>`;

  const NAMED_COLORS = {
    blue: "#1f78c8",
    red: "#c33f49",
    green: "#237e4b",
    yellow: "#a57700",
    purple: "#6d4cb3",
    cyan: "#0b7b88",
    orange: "#b5621e",
    pink: "#b43f8e",
    white: "#ffffff",
    black: "#111111",
    gray: "#646d78",
    grey: "#646d78"
  };

  const STYLE_TAGS = new Set(["center", "glow", "muted", "bold", "round"]);
  const UI_TAGS = new Set(["button"]);
  const MOTION_TAGS = new Set(["spin", "fade"]);

  const KNOWN_TAGS = new Set([
    ...STYLE_TAGS,
    ...UI_TAGS,
    ...MOTION_TAGS,
    ...Object.keys(NAMED_COLORS)
  ]);

  const THEMES = {
    default: {
      bg: "#fff8ef",
      text: "#1f232b",
      muted: "#5d6675",
      panel: "#ffffff",
      panelLine: "#e8dfce",
      accent: "#1f78c8"
    },
    slate: {
      bg: "#f0f4fb",
      text: "#111827",
      muted: "#5b6473",
      panel: "#ffffff",
      panelLine: "#d8e0ef",
      accent: "#1e55d6"
    },
    ink: {
      bg: "#151922",
      text: "#eef2ff",
      muted: "#acb8d6",
      panel: "#1d2330",
      panelLine: "#2a3345",
      accent: "#69a4ff"
    }
  };

  const sourceEl = document.getElementById("source");
  const previewEl = document.getElementById("preview");
  const htmlOutEl = document.getElementById("htmlOut");
  const previewStatusEl = document.getElementById("previewStatus");

  sourceEl.value = localStorage.getItem("weft_source") || DEFAULT_WEFT;

  function escapeHtml(text) {
    return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function isHexColor(value) {
    return /^#(?:[0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(value);
  }

  function isKnownTag(tag) {
    return KNOWN_TAGS.has(tag) || isHexColor(tag);
  }

  function splitLineTags(line) {
    let text = line;
    const tags = [];
    while (true) {
      const match = text.match(/\s*<([a-zA-Z]+|#[0-9a-fA-F]{3}|#[0-9a-fA-F]{6})>\s*$/);
      if (!match) {
        break;
      }
      const tag = match[1].toLowerCase();
      if (!isKnownTag(tag)) {
        break;
      }
      tags.unshift(tag);
      text = text.slice(0, match.index);
    }
    return { text, tags };
  }

  function parseMetadata(lines) {
    const meta = {};
    let idx = 0;

    while (idx < lines.length) {
      const line = lines[idx];
      const trimmed = line.trim();
      if (trimmed === "") {
        idx += 1;
        continue;
      }
      if (!trimmed.startsWith("@")) {
        break;
      }

      const match = trimmed.match(/^@([a-zA-Z][a-zA-Z0-9_-]*)\s*(.*)$/);
      if (!match) {
        idx += 1;
        continue;
      }

      const key = match[1].toLowerCase();
      const value = (match[2] || "").trim();
      meta[key] = value;
      idx += 1;
    }

    return { meta, contentLines: lines.slice(idx) };
  }

  function classifyLine(raw) {
    const line = raw.trim();

    if (line === "") {
      return { type: "gap" };
    }

    if (line === "---") {
      return { type: "hr" };
    }

    const headingMatch = raw.match(/^\s*(#{1,4})\s+(.*)$/);
    if (headingMatch) {
      const level = headingMatch[1].length;
      const parsed = splitLineTags(headingMatch[2]);
      return { type: "heading", level, text: parsed.text, tags: parsed.tags };
    }

    const imageMatch = raw.match(/^\s*!\[([^\]]*)\]\(([^)]+)\)\s*(.*)$/);
    if (imageMatch) {
      const parsed = splitLineTags(imageMatch[3] || "");
      return {
        type: "image",
        alt: imageMatch[1],
        src: imageMatch[2].trim(),
        tags: parsed.tags
      };
    }

    const parsed = splitLineTags(raw.trim());
    return { type: "paragraph", text: parsed.text, tags: parsed.tags };
  }

  function parseFenceStart(raw) {
    const trimmed = raw.trim();
    if (!trimmed.startsWith("```")) {
      return null;
    }
    const language = trimmed.slice(3).trim();
    return { language: language || null };
  }

  function isFenceClose(raw) {
    const trimmed = raw.trim();
    return trimmed.startsWith("```") && /^`+$/.test(trimmed);
  }

  function codeBlockFromLines(language, lines) {
    return { type: "code_block", language, code: lines.join("\n") };
  }

  function parseCardItems(lines) {
    const items = [];
    let insideCodeFence = false;
    let codeFenceLanguage = null;
    let codeFenceLines = [];

    for (const rawLine of lines) {
      if (insideCodeFence) {
        if (isFenceClose(rawLine)) {
          items.push(codeBlockFromLines(codeFenceLanguage, codeFenceLines));
          insideCodeFence = false;
          codeFenceLanguage = null;
          codeFenceLines = [];
        } else {
          codeFenceLines.push(rawLine);
        }
        continue;
      }

      const fence = parseFenceStart(rawLine);
      if (fence) {
        insideCodeFence = true;
        codeFenceLanguage = fence.language;
        codeFenceLines = [];
        continue;
      }

      items.push(classifyLine(rawLine));
    }

    if (insideCodeFence) {
      items.push(codeBlockFromLines(codeFenceLanguage, codeFenceLines));
    }

    return items;
  }

  function parseStructure(lines) {
    const blocks = [];
    let insideCard = false;
    let cardLines = [];
    let cardInsideCodeFence = false;
    let insideCodeFence = false;
    let codeFenceLanguage = null;
    let codeFenceLines = [];

    for (const rawLine of lines) {
      if (insideCodeFence) {
        if (isFenceClose(rawLine)) {
          blocks.push(codeBlockFromLines(codeFenceLanguage, codeFenceLines));
          insideCodeFence = false;
          codeFenceLanguage = null;
          codeFenceLines = [];
        } else {
          codeFenceLines.push(rawLine);
        }
        continue;
      }

      if (insideCard) {
        if (cardInsideCodeFence) {
          cardLines.push(rawLine);
          if (isFenceClose(rawLine)) {
            cardInsideCodeFence = false;
          }
          continue;
        }

        if (parseFenceStart(rawLine)) {
          cardInsideCodeFence = true;
          cardLines.push(rawLine);
          continue;
        }

        if (rawLine.trim() === ":::") {
          blocks.push({ type: "card", items: parseCardItems(cardLines) });
          insideCard = false;
          cardLines = [];
          continue;
        }

        cardLines.push(rawLine);
        continue;
      }

      if (rawLine.trim() === ":::") {
        insideCard = true;
        cardLines = [];
        continue;
      }

      const fence = parseFenceStart(rawLine);
      if (fence) {
        insideCodeFence = true;
        codeFenceLanguage = fence.language;
        codeFenceLines = [];
        continue;
      }

      blocks.push(classifyLine(rawLine));
    }

    if (insideCodeFence) {
      blocks.push(codeBlockFromLines(codeFenceLanguage, codeFenceLines));
    }

    if (insideCard) {
      blocks.push({ type: "card", items: parseCardItems(cardLines) });
    }

    return blocks;
  }

  function markdownInline(text) {
    let i = 0;
    let out = "";

    while (i < text.length) {
      if (text.startsWith("`", i)) {
        const end = text.indexOf("`", i + 1);
        if (end !== -1) {
          out += `<code>${escapeHtml(text.slice(i + 1, end))}</code>`;
          i = end + 1;
          continue;
        }
      }

      if (text.startsWith("**", i)) {
        const end = text.indexOf("**", i + 2);
        if (end !== -1) {
          out += `<strong>${markdownInline(text.slice(i + 2, end))}</strong>`;
          i = end + 2;
          continue;
        }
      }

      if (text.startsWith("[", i)) {
        const closeBracket = text.indexOf("]", i + 1);
        if (closeBracket !== -1 && text[closeBracket + 1] === "(") {
          const closeParen = text.indexOf(")", closeBracket + 2);
          if (closeParen !== -1) {
            const label = text.slice(i + 1, closeBracket);
            const href = text.slice(closeBracket + 2, closeParen).trim();
            out += `<a href="${escapeHtml(href)}" target="_blank" rel="noreferrer noopener">${markdownInline(label)}</a>`;
            i = closeParen + 1;
            continue;
          }
        }
      }

      out += escapeHtml(text[i]);
      i += 1;
    }

    return out;
  }

  function parseInlineTags(text) {
    const root = { tag: null, children: [] };
    const stack = [root];
    let i = 0;

    while (i < text.length) {
      if (text[i] === "`") {
        const end = text.indexOf("`", i + 1);
        if (end !== -1) {
          stack[stack.length - 1].children.push({ type: "text", value: text.slice(i, end + 1) });
          i = end + 1;
          continue;
        }
      }

      if (text[i] === "<") {
        const tokenMatch = text.slice(i).match(/^<\/?([a-zA-Z]+|#[0-9a-fA-F]{3}|#[0-9a-fA-F]{6})>/);
        if (tokenMatch) {
          const full = tokenMatch[0];
          const tag = tokenMatch[1].toLowerCase();
          const isClosing = full.startsWith("</");

          if (!isKnownTag(tag)) {
            stack[stack.length - 1].children.push({ type: "text", value: full });
            i += full.length;
            continue;
          }

          if (!isClosing) {
            const node = { type: "tag", tag, children: [], rawOpen: full };
            stack.push(node);
            i += full.length;
            continue;
          }

          if (stack.length > 1 && stack[stack.length - 1].tag === tag) {
            const closed = stack.pop();
            stack[stack.length - 1].children.push(closed);
          } else {
            stack[stack.length - 1].children.push({ type: "text", value: full });
          }

          i += full.length;
          continue;
        }
      }

      const nextLt = text.indexOf("<", i);
      const nextTick = text.indexOf("`", i);
      let next = text.length;
      if (nextLt !== -1) {
        next = Math.min(next, nextLt);
      }
      if (nextTick !== -1) {
        next = Math.min(next, nextTick);
      }
      if (next === i) {
        stack[stack.length - 1].children.push({ type: "text", value: text[i] });
        i += 1;
        continue;
      }
      stack[stack.length - 1].children.push({ type: "text", value: text.slice(i, next) });
      i = next;
    }

    while (stack.length > 1) {
      const unclosed = stack.pop();
      const fallback = {
        type: "text",
        value: unclosed.rawOpen + unclosed.children.map(renderInlineNodeLiteral).join("")
      };
      stack[stack.length - 1].children.push(fallback);
    }

    return root.children;
  }

  function renderInlineNodeLiteral(node) {
    if (node.type === "text") {
      return node.value;
    }
    return node.rawOpen + node.children.map(renderInlineNodeLiteral).join("");
  }

  function tagsToAttrs(tags) {
    const classes = [];
    let color = "";
    for (const tag of tags) {
      if (NAMED_COLORS[tag]) {
        color = NAMED_COLORS[tag];
      } else if (isHexColor(tag)) {
        color = tag;
      } else {
        classes.push(tag);
      }
    }
    let attrs = "";
    if (classes.length) {
      attrs += ` class="${classes.map(escapeHtml).join(" ")}"`;
    }
    if (color) {
      attrs += ` style="color:${escapeHtml(color)};"`;
    }
    return attrs;
  }

  function renderInlineNode(node) {
    if (node.type === "text") {
      return markdownInline(node.value);
    }

    const attrs = tagsToAttrs([node.tag]);
    const inner = node.children.map(renderInlineNode).join("");
    return `<span${attrs}>${inner}</span>`;
  }

  function renderInlineText(text) {
    const tree = parseInlineTags(text);
    return tree.map(renderInlineNode).join("");
  }

  function renderBlock(block) {
    if (block.type === "gap") {
      return `<div class="w-gap" aria-hidden="true"></div>`;
    }
    if (block.type === "hr") {
      return "<hr>";
    }
    if (block.type === "code_block") {
      const classAttr = block.language ? ` class="language-${escapeHtml(block.language)}"` : "";
      return `<pre><code${classAttr}>${escapeHtml(block.code)}</code></pre>`;
    }
    if (block.type === "heading") {
      const attrs = tagsToAttrs(block.tags);
      return `<h${block.level}${attrs}>${renderInlineText(block.text)}</h${block.level}>`;
    }
    if (block.type === "image") {
      const attrs = tagsToAttrs(block.tags);
      return `<figure${attrs}><img src="${escapeHtml(block.src)}" alt="${escapeHtml(block.alt)}"></figure>`;
    }
    if (block.type === "paragraph") {
      const attrs = tagsToAttrs(block.tags);
      return `<p${attrs}>${renderInlineText(block.text)}</p>`;
    }
    if (block.type === "card") {
      const inner = block.items.map(renderBlock).join("");
      return `<article class="w-card">${inner}</article>`;
    }
    return "";
  }

  function renderBlocks(blocks) {
    let html = "";
    let i = 0;

    while (i < blocks.length) {
      if (blocks[i].type === "card") {
        const row = [];
        while (i < blocks.length && blocks[i].type === "card") {
          row.push(blocks[i]);
          i += 1;
        }
        html += `<section class="w-card-row">${row.map(renderBlock).join("")}</section>`;
        continue;
      }

      const block = blocks[i];
      if (block.type === "gap") {
        if (i === 0 || blocks[i - 1].type === "gap") {
          i += 1;
          continue;
        }
      }

      html += renderBlock(block);
      i += 1;
    }

    return html;
  }

  function hasMotion(tags) {
    return tags.some((tag) => MOTION_TAGS.has(tag));
  }

  function collectMotion(blocks) {
    for (const block of blocks) {
      if (block.type === "card") {
        if (collectMotion(block.items)) {
          return true;
        }
      } else if (block.tags && hasMotion(block.tags)) {
        return true;
      }
    }
    return false;
  }

  function themeFromMeta(meta) {
    const requested = (meta.theme || "default").toLowerCase();
    const base = THEMES[requested] || THEMES.default;

    let accent = (meta.accent || base.accent).toLowerCase();
    if (NAMED_COLORS[accent]) {
      accent = NAMED_COLORS[accent];
    }
    if (!isHexColor(accent)) {
      accent = base.accent;
    }

    return { ...base, accent };
  }

  function compileWeft(source) {
    const normalized = source.replace(/\r\n?/g, "\n");
    const lines = normalized.split("\n");
    const { meta, contentLines } = parseMetadata(lines);
    const blocks = parseStructure(contentLines);
    const content = renderBlocks(blocks);
    const withMotion = collectMotion(blocks);
    const theme = themeFromMeta(meta);

    const title = meta.title || "Weft Page";
    const desc = meta.desc || "Compiled from Weft";

    const style = `
:root{
  --w-bg:${theme.bg};
  --w-text:${theme.text};
  --w-muted:${theme.muted};
  --w-panel:${theme.panel};
  --w-line:${theme.panelLine};
  --w-accent:${theme.accent};
}
*{box-sizing:border-box}
body{
  margin:0;
  padding:40px min(4vw,40px);
  font:16px/1.65 "Avenir Next","Segoe UI",sans-serif;
  color:var(--w-text);
  background:
    radial-gradient(900px 400px at 95% -10%, color-mix(in srgb, var(--w-accent), white 82%) 0%, transparent 55%),
    var(--w-bg);
}
main{max-width:1100px;margin:0 auto}
h1,h2,h3,h4{line-height:1.2;margin:0.6em 0 0.45em}
h1{font-size:clamp(1.9rem,5vw,3.2rem)}
h2{font-size:clamp(1.5rem,3vw,2.2rem)}
h3{font-size:1.3rem}
h4{font-size:1.1rem}
p{margin:0.65em 0}
a{color:var(--w-accent)}
hr{border:0;border-top:1px solid var(--w-line);margin:1.2rem 0}
pre{margin:0.9rem 0;padding:12px 14px;overflow:auto;border:1px solid var(--w-line);border-radius:12px;background:color-mix(in srgb,var(--w-line),white 50%)}
figure{margin:0.9rem 0}
img{max-width:100%;height:auto;display:block;border-radius:12px}
code{font-family:"Cascadia Code","Consolas",monospace;background:color-mix(in srgb,var(--w-line),white 35%);padding:0.1rem 0.35rem;border-radius:6px}
pre code{display:block;padding:0;border-radius:0;background:transparent;white-space:pre}
.w-gap{height:0.8rem}
.w-card-row{display:grid;grid-template-columns:repeat(auto-fit,minmax(210px,1fr));gap:14px;margin:0.8rem 0}
.w-card{background:var(--w-panel);border:1px solid var(--w-line);border-radius:16px;padding:14px 15px;box-shadow:0 8px 20px rgba(0,0,0,0.08)}
.center{text-align:center}
.glow{
  color:color-mix(in srgb,var(--w-accent),white 16%);
  text-shadow:
    0 0 8px color-mix(in srgb,var(--w-accent),white 35%),
    0 0 20px color-mix(in srgb,var(--w-accent),transparent 6%),
    0 0 42px color-mix(in srgb,var(--w-accent),transparent 20%),
    0 0 78px color-mix(in srgb,var(--w-accent),transparent 42%);
  animation:w-glow-pulse 1800ms ease-in-out infinite alternate;
}
@keyframes w-glow-pulse{
  from{
    text-shadow:
      0 0 7px color-mix(in srgb,var(--w-accent),white 30%),
      0 0 18px color-mix(in srgb,var(--w-accent),transparent 12%),
      0 0 36px color-mix(in srgb,var(--w-accent),transparent 28%),
      0 0 60px color-mix(in srgb,var(--w-accent),transparent 48%);
  }
  to{
    text-shadow:
      0 0 10px color-mix(in srgb,var(--w-accent),white 44%),
      0 0 26px color-mix(in srgb,var(--w-accent),transparent 4%),
      0 0 58px color-mix(in srgb,var(--w-accent),transparent 16%),
      0 0 96px color-mix(in srgb,var(--w-accent),transparent 36%);
  }
}
.muted{color:var(--w-muted)}
.bold{font-weight:700}
.round img,img.round{border-radius:20px}
.button a,a.button{display:inline-block;background:var(--w-accent);color:#fff!important;text-decoration:none;padding:0.48rem 0.82rem;border-radius:999px;font-weight:600}
.fade{opacity:0;transform:translateY(16px)}
.spin{display:inline-block}
`;

    const script = withMotion ? `
(function(){
  var reduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  if (reduce) {
    document.querySelectorAll('.fade').forEach(function(el){
      el.style.opacity = '1';
      el.style.transform = 'none';
    });
    return;
  }

  var faders = document.querySelectorAll('.fade');
  if ('IntersectionObserver' in window) {
    var io = new IntersectionObserver(function(entries){
      entries.forEach(function(entry){
        if (entry.isIntersecting) {
          entry.target.animate([
            { opacity: 0, transform: 'translateY(16px)' },
            { opacity: 1, transform: 'translateY(0)' }
          ], { duration: 500, easing: 'ease-out', fill: 'forwards' });
          io.unobserve(entry.target);
        }
      });
    }, { threshold: 0.12 });
    faders.forEach(function(el){ io.observe(el); });
  } else {
    faders.forEach(function(el){
      el.style.opacity = '1';
      el.style.transform = 'none';
    });
  }

  document.querySelectorAll('.spin').forEach(function(el){
    el.animate(
      [{ transform: 'rotate(0deg)' }, { transform: 'rotate(360deg)' }],
      { duration: 2300, iterations: Infinity, easing: 'linear' }
    );
  });
})();
` : "";

    const html = `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>${escapeHtml(title)}</title>
<meta name="description" content="${escapeHtml(desc)}">
<style>${style}</style>
</head>
<body>
<main>${content}</main>
${withMotion ? `<script>${script}<\/script>` : ""}
</body>
</html>`;

    return { html, meta, withMotion };
  }

  function render() {
    try {
      localStorage.setItem("weft_source", sourceEl.value);
      const output = compileWeft(sourceEl.value);
      previewEl.srcdoc = output.html;
      htmlOutEl.textContent = output.html;
      previewStatusEl.textContent = output.withMotion ? "Ready (motion enabled)" : "Ready";
    } catch (error) {
      previewStatusEl.textContent = "Compile error";
      htmlOutEl.textContent = String(error && error.message ? error.message : error);
      previewEl.srcdoc = "<pre style=\"font-family:monospace;padding:16px\">Compile error</pre>";
    }
  }

  let raf = 0;
  function scheduleRender() {
    if (raf) {
      cancelAnimationFrame(raf);
    }
    raf = requestAnimationFrame(() => {
      raf = 0;
      render();
    });
  }

  sourceEl.addEventListener("input", scheduleRender);

  document.getElementById("btnReset").addEventListener("click", () => {
    localStorage.removeItem("weft_source");
    sourceEl.value = DEFAULT_WEFT;
    render();
  });

  document.getElementById("btnExample").addEventListener("click", () => {
    sourceEl.value = DEFAULT_WEFT;
    render();
  });

  document.getElementById("btnCopyWeft").addEventListener("click", async () => {
    await navigator.clipboard.writeText(sourceEl.value);
  });

  document.getElementById("btnCopyHtml").addEventListener("click", async () => {
    await navigator.clipboard.writeText(htmlOutEl.textContent || "");
  });

  document.getElementById("btnDownload").addEventListener("click", () => {
    const html = htmlOutEl.textContent || "";
    const blob = new Blob([html], { type: "text/html;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "page.html";
    a.click();
    URL.revokeObjectURL(url);
  });

  render();
})();
</script>
</body>
</html>
